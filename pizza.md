# 🍕 오늘 배운 내용 = 피자나라 치킨공주 비유

## 사람에게 의견을 묻는 노드
→ 손님에게 *“불고기 피자로 하시겠습니까, 페퍼로니로 하시겠습니까?”* 라고 직접 물어보는 것.  
- LangGraph에서 **인간 입력을 기다리는 노드** = 피자나라 치킨공주 점원이 손님에게 메뉴를 물어보는 순간.  

---

## 일정 메시지 개수가 넘어가면 삭제되는 코드 (대화기록 요약)
→ 손님과 점원이 대화를 너무 길게 하면,  
- *“이전 주문은 간단히 요약(피자=불고기, 사이드=치킨)”* 하고  
- 최근 대화(마지막 질문·답변)만 남겨둔다.  

즉, 오래된 주문지는 버리고 간단한 메모만 남기는 피자나라 치킨공주 주방.  

---

## ToolNode를 사용하여 도구를 호출하는 방법
→ 피자나라 치킨공주 주방에 있는 **도구들** (오븐, 튀김기, 배달앱 API 같은 것).  
- ToolNode = *“오븐 돌려라!”*, *“치킨 튀김기 가동해라!”* 같은 구체적 지시.  

---

## Agent와 함께 ToolNode를 사용하는 방법
→ 매니저(Agent)가 들어와서 *“손님이 피자+치킨 세트 주문했네. 오븐이랑 튀김기 동시에 돌려!”* 라고 지시하는 것.  
- 매니저는 **상황 판단 + 도구 호출**을 대신함.  

---

## 병렬 노드 분기 (fan-out)
→ 피자와 치킨을 동시에 조리 시작.  
- 오븐은 피자, 튀김기는 치킨.  

---

## fan-in
→ 피자와 치킨이 **둘 다 완성**되어야 배달 출발.  
- *“치킨 다 됐는데 피자는 아직이네? 기다려!”* 같은 상황.  

---

## conditional branching
→ 손님 주문 확인 후:  
- 피자만 주문 → 피자 라인만 실행  
- 피자+치킨 세트 주문 → 두 라인 병렬 실행  
- 스파게티는 주문 안했으면 아예 건너뜀  

---

## fan-out 값의 신뢰도 (reliability)에 따른 정렬
→ 피자나라 치킨공주 주방에서 메뉴별 “우선순위” 정하기.  
- 피자 (0.8) → 대표 메뉴라 먼저 손댐  
- 치킨 (0.6) → 그다음  
- 스파게티 (0.3) → 서브 메뉴라 마지막  

👉 하지만 결국 세트 주문이면 **모두 완성돼야 배달 출발**.  

---

## 대화기록 요약 (메시지 6개 넘으면 요약 후 최근만 남김)
→ 손님이 계속 요구를 바꾸면 주문서가 복잡해짐.  
- 그래서 *“이전 주문 요약”*만 남기고 최근 변경 사항만 기록.  
- 예: *“손님: 불고기 피자로 변경 / 점원: 확인했습니다”*  

---

## Naive RAG
→ 아르바이트생이 피자나라 치킨공주 매뉴얼북을 펼쳐 레시피 찾음.  
- 주문 들어오면 책에서 관련 페이지를 찾아서 그대로 조리 시작.  
- “찾고 바로 쓰는 단순 방식” = Naive RAG  

---

## 클래스 상속
→ 주방 매뉴얼을 코드로 표현하면,  
- `BasePizza` = 모든 피자가 공통으로 가지는 속성(도우 굽기, 소스 바르기)  
- `BulgogiPizza` = `BasePizza` 상속 + 불고기 토핑 추가  
- `PepperoniPizza` = `BasePizza` 상속 + 페퍼로니 토핑 추가  

→ 이렇게 해서 피자나라 치킨공주 레시피 코드가 깔끔해짐.  

---

# ✅ 정리
오늘 배운 LangGraph 기능들을 피자나라 치킨공주로 비유하면,  

- **Agent = 매니저**  
- **ToolNode = 주방 도구(오븐, 튀김기)**  
- **fan-out = 피자+치킨 동시 조리**  
- **fan-in = 둘 다 끝나야 배달 출발**  
- **조건부 분기 = 손님 주문에 따라 조리 라인 선택**  
- **신뢰도 = 주방에서 메뉴별 우선순위**  
- **대화 요약 = 주문 내역 정리**  
- **Naive RAG = 메뉴북 레시피 찾아 그대로 조리**  
- **클래스 상속 = 기본 피자 레시피 + 토핑만 변경**  

👉 LangGraph = **피자나라 치킨공주 경영 시뮬레이터** 🍕🐔🍝

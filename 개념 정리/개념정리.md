# 🧩 LangGraph의 정확한 흐름 정리

## 1. State 정의
- **State = 주문지 / 공용 데이터판**
- 그래프 전체에서 공유되는 데이터 구조
- `TypedDict` 등을 사용하여 어떤 타입의 정보가 담길지 미리 정의
- 예: `messages`, `aggregate`, 사용자 query, tool 결과 등

---

## 2. Agent 정의
- **Agent = 매니저(두뇌)**
- LLM + Tool 목록으로 구성
- 역할:
  - 사용자 query를 해석
  - 툴이 필요하면 어떤 툴을 쓸지 결정
  - 툴 결과를 받아 다시 판단 (추가 툴 사용 or 종료)

---

## 3. Tool 정의
- **Tool = 주방 도구**
- Agent가 선택해야만 실행됨
- 외부 기능(API, 계산, 검색 등)을 캡슐화
- 실행 결과는 다시 State에 기록됨

---

## 4. Node 구성
- Agent와 Tool을 각각 노드로 추가
- 각 노드는 **state → state** 변환을 수행
- `add_node("agent", agent_func)`  
- `add_node("tool", tool_node)`

---

## 5. Edge 연결
- 노드 간 실행 순서를 정의
- `add_edge("agent", "tool")` 처럼 직선 연결
- 여러 분기로 나누려면 `add_conditional_edges` 사용
  - 조건에 따라 특정 노드만 실행
  - 리스트를 반환하면 병렬 실행(fan-out)

---

## 6. 실행 플로우
1. **시작 (START)**
   - 사용자 query가 State에 들어옴
2. **Agent 실행**
   - query를 읽고 "툴을 쓸까?" 판단
3. **Tool 실행 (선택적)**
   - Agent가 지정한 툴이 실행됨
   - 결과를 State에 추가
4. **Agent 재실행**
   - 결과를 확인 후:
     - 추가 툴 실행 여부 결정
     - 혹은 최종 답변 준비
5. **조건 분기 / 병렬 실행**
   - `conditional_edges`로 여러 노드로 나눌 수 있음
   - fan-out: 동시에 여러 작업
   - fan-in: 모두 끝나야 다음으로 진행
6. **END 도달**
   - Agent가 "더 이상 툴 필요 없음" 판단 시 END로 종료

---

## 7. 보조 개념
- **대화기록 요약**: 메시지가 많아지면 요약 후 최근만 유지
- **신뢰도(reliability)**: 여러 병렬 후보가 있을 때 실행 우선순위를 정렬
- **클래스 상속**: 공통 로직을 묶고, 특정 노드 동작만 확장

---

# ✅ 핵심 요약
- **State**: 데이터 흐름의 기반
- **Agent**: 판단자 (툴 사용 여부 결정)
- **Tool**: 실행자 (Agent가 지시해야 작동)
- **Node**: Agent/Tool 실행 단위
- **Edge**: 실행 순서 정의
- **Conditional/Fan-out/Fan-in**: 분기/병렬/합류 제어
- **END**: Agent가 종료 판단 시 도달

👉 LangGraph는 결국 **“State를 공유하는 Agent-Tool 오케스트레이션 그래프”** 라고 볼 수 있다.
